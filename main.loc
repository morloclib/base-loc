module root (*)

import internal

-- declaring these types here allow imports of types from roots
type Unit
type Real
type Int
type Str
type Bool
type Map a b
type List a
type Tuple2 a b
type Tuple3 a b c
type Tuple4 a b c d
type Tuple5 a b c d e
type Tuple6 a b c d e f
type Tuple7 a b c d e f g
type Tuple8 a b c d e f g h

type Filename = Str

class Eq a where
  eq a :: a -> a -> Bool

ifelse a :: Bool -> a -> a -> a 
branch a :: (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b

class Ord a where
  le a :: a -> a -> Bool

lt x y = and (le x y) (not (le y x))
ge x y = le y x
gt x y = and (le y x) (not (le x y))

lesser a :: a -> a -> a
lesser x y = ifelse (lt x y) x y

greater a :: a -> a -> a
greater x y = ifelse (lt x y) y x

ne a :: a -> a -> Bool
ne x y = not (eq x y)

class Monoid a where
  mempty a :: a
  mappend a :: a -> a -> a

class Integral a where
  zero a :: a
  neg a :: a -> a
  add a :: a -> a -> a
  sub a :: a -> a -> a
  mul a :: a -> a -> a 

class Numeric a where
  one a :: a
  inv a :: a -> a
  div a :: a -> a -> a 
  exp a :: a -> a -> a
  log a :: a -> a -> a

class Foldable f where
  fold f a b :: (b -> a -> b) -> b -> f a -> b

-- O(n), you should probably provide a constant-time implementation for each type
length f a :: f a -> Int
length = fold (\b a -> add 1 b) 0

class Functor f where
  map f a b :: (a -> b) -> f a -> f b

-- class Bifunctor f where
--   bimap f a a' b b' :: (a -> a') -> (b -> b') -> f a b -> f a' b'
--   onA f a a' b :: (a -> a') -> f a b -> f a' b
--   onB f a b b' :: (b -> b') -> f a b -> f a b'
--
-- instance Bifunctor Tuple2 where
--   bimap f g x = (f (fst x), g (snd x))
--   onA f x = (f (fst x), snd x)
--   onB g x = (fst x, g (snd x))

-- all sequences are Addable, Foldable, Filterable and Functors
-- they additionally have a defined order and are isomorphic to lists
-- unlike functors, they can be split
class Sequence f where
    empty f a :: f a

    -- at -1 [1,2,3] == FUCK!!!
    -- at 0  [1,2,3] == 1
    -- at 2  [1,2,3] == 3
    -- at 4  [1,2,3] == FUCK!!!
    at f a :: Int -> f a -> a

    -- slice 0 0 [1,2,3] == []
    -- slice 0 1 [1,2,3] == [1]
    -- slice 1 0 [1,2,3] == []    -- this doesn't reverse
    -- slice 1 3 [1,2,3] == [2,3]
    -- slice 1 4 [1,2,3] == [2,3] -- length may not equal j - i
    -- slice 3 4 [1,2,3] == []
    slice f a :: Int -> Int -> f a -> f a


-- list-specific zip - should generalize, but this is used in tests
zipWith a b c :: (a -> b -> c) -> [a] -> [b] -> [c]

-- warning: unsafe
-- time: O(1)
head f a :: f a -> a -- [1,2,3] => 1
head xs = at 0 xs

-- time: O(n)
init f a :: f a -> f a
init xs = slice 0 (sub (length xs) 1) xs

last f a :: f a -> a -- [1,2,3] => 3
last xs = at (sub (length xs) 1) xs

tail f a :: f a -> f a -- [1,2,3] => [2,3]
tail xs = slice 1 (length xs) xs

take f a :: Int -> f a -> f a
take i xs = slice 0 i xs

drop f a :: Int -> f a -> f a
drop i xs = slice i (length xs) xs


id a :: a -> a
id x = x

seq a b :: a -> b -> b
seq x y = y

const a b :: a -> b -> a
const x y = x

flip a b c :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

-- From the "To Mock a Mockingbird" aviary
starling a b c d :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
starling bcd ab ac a = bcd (ab a) (ac a)


and :: Bool -> Bool -> Bool
or :: Bool -> Bool -> Bool
not :: Bool -> Bool

xor :: Bool -> Bool -> Bool
xor x y = and (nand x y) (nand (not x) (not y))

nand :: Bool -> Bool -> Bool
nand x y = not (and x y)


fst a b :: (a, b) -> a
snd a b :: (a, b) -> b
fst3 a b c :: (a, b, c) -> a
snd3 a b c :: (a, b, c) -> b
thr3 a b c :: (a, b, c) -> c

curry a b c :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)

curry3 a b c d :: ((a, b, c) -> d) -> a -> b -> c -> d
curry3 f x y z = f (x, y, z)

uncurry a b c :: (a -> b -> c) -> (a, b) -> c
uncurry f xy = f (fst xy) (snd xy)

uncurry3 a b c d :: (a -> b -> c -> d) -> (a, b, c) -> d
uncurry3 f xyz = f (fst3 xyz) (snd3 xyz) (thr3 xyz)

toSnd a b :: (a -> b) -> a -> (a, b)
toSnd f x = (x, f x)

toFst a b :: (a -> b) -> a -> (b, a)
toFst f x = (f x, x)
